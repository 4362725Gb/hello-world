
گیت (git) یک open source distributed version control system هست که تغییرات روی فایل ها رو رهگیری می‌کنه و در واقع ورژن‌های مختلف از فایل ها رو برای ما در دسترس و قابل مدیریت می‌کند.
تفاوتش با git hub (که جلسه بعد ارایه میشه) به طور خلاصه اینه که گیت یک نرم افزار هست و در واقع محلی local هست اما گیت هاب یک سرویس انلاین هست که به افراد مختلف امکان کار روی یک پروژه بدون اینکه تداخل ایجاد بشه محیا می کنه.
‏repositoy جایی هست مثل یک folder که فایل های پروژه اونجا، نگهداری می شه
اگر روند زمانی تغییرات پروژه و شکل گیری نسخه های مختلف رو یک مسیر در نظر بگیریم، مسیر اصلی در واقع باثبات‌ترین نسخه از پروژه مون هست (معمولا با اسم master می‌شناسیمش). حالا اگه چند نفر/گروه بخوان به طور همزمان رو پروژه کار کنن، از مسیر اصلی انشعاب می‌گیرن و تغییرات رو اعمال می‌کنن و بعد دوباره به مسیر اصلی merge میشن.
برای داشتن git بر روی سیستم‌عامل ویندوز نیازمند install کردن آن هستیم ولی به صورت دیفالت رو لینوکس هست.
برای کار با git هم از cmd ویندوز میشه استفاده کرد هم از فضای gitBash که باتوجه به چند رنگه بودنش، کار باهاش راحت‌تره (از داخل فضای ژوپیتر نوت‌بوک هم می شه با علامت ! فرمان برای cmd فرستاد) 
یه راه ساده برای اینکه چک کنیم که نصب شده یا نه میشه از دستور زیر (در cmd) چک کرد.
git --version
بعد از نصب با استفاده از دستور git init کار رو شروع می‌کنیم و گیت یک سری فایل در پوشه کاری ما ایجاد می کنه تا فضا برای کارهای خودش محیا کنه. 
برای پیکر بندی ابتدا باید خودمون رو به گیت معرفی کنیم که چه کسی داره روی پروژه کار می‌کنه
برای configuration نام و ایمیل رو به git معرفی می کنیم برای مثال وقتی میخوایم اسم‌گذاری کنیم از دستور  git config user.name استفاده می‌کنیم.
برای توضیح درباره فرمان یا کمک گرفتن از flag (کلید)  -h بعد از اون فرمان میشه استفاده کرد. مثلا git log -h

پروسه کار به این صورت زیر هست:
برای اینکه فایل های مورد نظر رو (که در ابندا در working directory هستند و گیت بهشون کاری نداره و به عنوان untracked files می شناسه ) به گیت معرفی کنیم که زیر نظر بگیره ، باید فایل ها رو به فضای stage بفرستیم و هنگامی که ویرایش برنامه ای که در حال نوشتن آن هستیم تموم شد فایل رو با دستور commit نهایی می کنیم 
[working directory]
> git add filename
[stage]
> git commit -m 'description' filename
[repository]
در هر مرحله با دستور git status می تونیم از تغییرات فایل ها و اینکه فایل ها در کدام مرحله هستند آگاه بشیم 
به عنوان یک مثال، وقتی یک فایل جدید در پوشه کاری ایجاد کنیم (با دستور git touch از خط فرمان هم میشه new file  ایجاد کرد(در ویندوز)) ، گیت فایل رو untracked گزارش می کنه، برای اینکه بیاریمش رو stage تا گیت تغییراتشو زیر نظر بگیره با دستور git add  این کار انجام میشه و بعد از تغییرات نهایی با دستور git commit به گیت می فهمونیم که این نسخه از فایل اماده استفاده در پروژه هست.
 برای commit باید یک کامنت هم تو “” بزاریم که توضیح بدیم چه اتفاقی افتاده. برای جمله ی توضیح هم از simple present tense به جای past tense استفاده می کنند.

برای اینکه یک نسخه از پروژه دراختیار کسی بزاریم که روی توسعه برنامه میخواد کار کنه، یک کپی از شاخه اصلی پروژه (master)، به عنوان یک شاخه فرعی (brabch) در اختیارش قرار می گیره
برای انشعاب گرفتن از دستور git branch developerName استفاده می‌کنیم.
برای اینکه میان شاخه های پروژه رفت و امد کنیم، دستور git checkout branchName رو اعمال می‌کنیم.
بعد از commit کردن فایل از یک شاخه توسط کسی که در حال توسعه برنامه هست ، برای اینکه تغییرات رو به master اضافه بکنیم با دستور git merge این کارو می‌کنیم (از mater branch قابل انجام هست).
برای از بین بردن یک شاخه که دیگه نیازی بهش نیست، ابتدا میریم تو master و از دستور branch -d و برای تغییر نام هم از branch -m استفاده می‌کنیم.

اگه در [working directory] یک سری فایل داریم که نیازی نیست توسط گیت track بشن، یک فایل خاص به نام(پسوندفایل) .gitignore به فولدر اضافه می‌کنیم و اسم فایل‌ها و پوشه هایی که می خواهیم گیت نادیده بگیره رو داخلش قرار می‌دیم.
با add کردن و سپس commit کردن فایل .gitignore  دیگه فایل های مورد نظر توسط گیت رهگیری نخواهند شد. 

با هر بار commit، در واقع یک checkpoint ایجاد می شه و مثل اینکه یک تصویر از کل پروژه ثبت بشه و شماره سریال بخوره، یک کد منحصر بفرد توسط گیت، به اون وضعیت از پروژه اختصاص داده می شه که با اون کد میشه در هر زمان به همون وضعیت فایل ها در پروژه برگشت کرد.
دستور git log ، همه این وضعیت ها از ابتدای پروژه رو لیست می کنه 
در قسمت بعدی از اینجا ادامه می دهیم و اینکه چطور به نسخه های قبلی در پروژه برگردیم.